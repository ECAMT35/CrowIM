spring:
  application:
    name: message-service
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
#url: TODO
#username: TODO
#password: TODO

  data:
    redis:
#host: TODO
      database: 0
#port: TODO
#password: TODO
      timeout: 10s
      lettuce:
        pool:
          max-active: 500
          max-wait: -1ms
          max-idle: 10
          min-idle: 0

  rabbitmq:
#host: TODO
#port: TODO
#username: TODO
#password: TODO

    # 生产者重试机制
    connection-timeout: 3s # 设置MQ的连接超时时间
    template:
      retry:
        enabled: true # 开启超时重试机制
        initial-interval: 1000ms # 失败后的初始等待时间
        multiplier: 2 # 失败后下次的等待时长倍数，下次等待时长 = initial-interval * multiplier
        max-attempts: 3

    # 消费者确认机制
    listener:
      simple:
        prefetch: 1 # 消费者一次性从队列中拉取多少条消息进行处理
        acknowledge-mode: auto # 自动消费者自动 ack 模式

        retry:
          enabled: true # 开启消费者本地失败重试
          initial-interval: 1000ms # 初始的失败等待时长为1秒
          multiplier: 2 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval
          stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false
          max-attempts: 3

logging:
  level:
    root: info

netty:
  websocket:
#port: TODO
    path: /ws
    max-frame-size: 65536
    idle-timeout: 60

snowflake:
  worker-id: 1
  data-center-id: 1

node-name: node1

# 设备在线状态过期时间, 单位：秒
# 其实实时性也不需要这么高，当用户断开连接的时候再从redis删除就好了
device-session-timeout: 3600